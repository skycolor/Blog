(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{666:function(n,t,e){"use strict";e.r(t);var o=e(7),s=Object(o.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("blockquote",[e("p",[n._v("浏览文档和论坛，从中get的一些小技巧")])]),n._v(" "),e("h3",{attrs:{id:"_1、-sync修饰符"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1、-sync修饰符"}},[n._v("#")]),n._v(" 1、.sync修饰符")]),n._v(" "),e("p",[n._v("很多时候，父子组件的prop需要做一个双向绑定，即父组件一个data传递给子组件，父组件提供方法给子组件以修改父组件的data。子组件通过emit方法调用传过来的方法。")]),n._v(" "),e("p",[n._v("以上有很多冗余代码，显得臃肿，而vue官方给出了.sync修饰符来约定以上情况的具体写法，具体如下")]),n._v(" "),e("p",[n._v("父组件")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('<template>\n  <div id="app">\n    <HelloWorld :isShow.sync="isShowContent" />\n    <hr/>\n    <button @click="isShowContent=true" >父组件控制-显示内容</button>\n    &nbsp;&nbsp;&nbsp;&nbsp;\n    <button @click="isShowContent=false" >父组件控制-隐藏内容</button>\n  </div>\n</template>\n\n<script>\nimport HelloWorld from \'./components/HelloWorld.vue\'\nexport default {\n  name: \'App\',\n  data() {\n    return {\n      isShowContent: false\n    }\n  },\n  components: {\n    HelloWorld\n  }\n}\n<\/script>\n')])])]),e("p",[n._v("子组件")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('<template>\n  <div class="hello_container">\n    <div class="content" v-show="isShow" >\n      我是子组件的内容文案！！！！！！！！！\n    </div>\n    <button @click="$emit(\'update:isShow\',true)" >子组件内控制-显示内容</button>\n    &nbsp;&nbsp;&nbsp;&nbsp;\n    <button @click="$emit(\'update:isShow\',false)" >子组件内控制-隐藏内容</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  props: [\'isShow\']\n}\n<\/script>\n')])])]),e("p",[e("em",[e("strong",[n._v("相当于用固定写法:XXX.sync向子组件传prop，而在子组件中也用固定的写法$emit('update:XXX',val)来修改父组件的data")])])]),n._v(" "),e("h3",{attrs:{id:"_2、is属性让代码更优雅"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2、is属性让代码更优雅"}},[n._v("#")]),n._v(" 2、is属性让代码更优雅")]),n._v(" "),e("p",[n._v("在业务上经常要用状态去控制不同组件的显示/隐藏，以下写法就比较low")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("<template>\n  <div id=\"app\">\n    <a-components v-if=\"type == 'a'\" ></a-components>\n    <b-components v-else-if=\"type == 'b'\" ></b-components>\n    <c-components v-else-if=\"type == 'c'\" ></c-components>\n  </div>\n</template>\n<script>\nimport aComponents from './components/a.vue'\nimport bComponents from './components/b.vue'\nimport cComponents from './components/c.vue'\nexport default {\n  data() {\n    return {\n      type: 'b'\n    }\n  },\n  components: {\n    aComponents, bComponents, cComponents\n  }\n}\n<\/script>\n")])])]),e("p",[n._v("可以换成is和component的写法，就会更清晰一点，不会让template代码区域很乱，也不需要在components属性中注册过多的组件，代码如下")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("<template>\n  <div id=\"app\">\n    <component :is=\"componentObj[type]\"></component>\n  </div>\n</template>\n\n<script>\nimport aComponents from './components/a.vue'\nimport bComponents from './components/b.vue'\nimport cComponents from './components/c.vue'\nexport default {\n  data() {\n    return {\n      type: 'a',\n      componentObj: {a: aComponents, b: bComponents, c: cComponents}\n    }\n  }\n}\n<\/script>\n")])])]),e("h3",{attrs:{id:"_3、hook"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3、hook"}},[n._v("#")]),n._v(" 3、hook")]),n._v(" "),e("p",[n._v("在vue中可以通过$on和$once去监听生命周期的钩子函数，即hook，可以让定时器的创建销毁代码在同一个生命周期函数内，如下代码")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("export default {\n  data(){\n    return {\n      timer: null\n    }\n  },\n  mounted(){\n    this.timer = setInterval(() => {\n      console.log('----setInterval-----');\n    }, 2000)\n    this.$once('hook:beforeDestroy', () => {\n      if(this.timer){\n        clearInterval(this.timer)\n      }\n      console.log('-----hook:beforeDestroy------');\n    })\n  },\n  beforeDestroy(){\n    console.log('------beforeDestroy-------');\n  }\n}\n")])])]),e("p",[n._v("在mounted方法中对timer进行了创建，同时监听beforeDestroy的hook钩子，以完成timer的销毁，在复杂的页面逻辑中还是很实用的，避免创建和销毁的代码相距很多行。以上代码的打印顺序为先beforeDestroy后hook:beforeDestroy，证明监听生命周期函数是在该函数执行完毕后再执行。")]),n._v(" "),e("p",[n._v("hook还可以用于父组件监听子组件的生命周期函数，看以下示例"),e("br"),n._v("\n父组件")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("<template>\n  <div class=\"home\">\n    <h1>This is an Home page</h1>\n    <p>监听子组件的update</p>\n    <count @hook:updated=\"childUpdateListener\" ></count>\n  </div>\n</template>\n\n<script>\nimport count from '@/components/count' \nexport default {\n  components: { count },\n  methods: {\n    childUpdateListener(){\n      console.log('-----child update-------');\n    }\n  }\n}\n<\/script>\n")])])]),e("p",[n._v("子组件")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('<template>\n  <div class="hello">\n    <span>{{ count }}</span>\n    <button @click="count++" >加法</button>\n  </div>\n</template>\n<script>\nexport default {\n  data() {\n    return {\n      count: 1\n    }\n  }\n}\n<\/script>\n')])])]),e("p",[n._v("在父组件中通过@hook:updated进行子组件update函数的监听，当子组件每次count做加法触发update时，父组件都会监听到并执行childUpdateListener方法")])])}),[],!1,null,null,null);t.default=s.exports}}]);