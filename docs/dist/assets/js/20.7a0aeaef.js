(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{666:function(t,n,e){"use strict";e.r(n);var s=e(7),o=Object(s.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("blockquote",[e("p",[t._v("浏览文档和论坛，从中get的一些小技巧")])]),t._v(" "),e("h3",{attrs:{id:"_1、-sync修饰符"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1、-sync修饰符"}},[t._v("#")]),t._v(" 1、.sync修饰符")]),t._v(" "),e("p",[t._v("很多时候，父子组件的prop需要做一个双向绑定，即父组件一个data传递给子组件，父组件提供方法给子组件以修改父组件的data。子组件通过emit方法调用传过来的方法。")]),t._v(" "),e("p",[t._v("以上有很多冗余代码，显得臃肿，而vue官方给出了.sync修饰符来约定以上情况的具体写法，具体如下")]),t._v(" "),e("p",[t._v("父组件")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<template>\n  <div id="app">\n    <HelloWorld :isShow.sync="isShowContent" />\n    <hr/>\n    <button @click="isShowContent=true" >父组件控制-显示内容</button>\n    &nbsp;&nbsp;&nbsp;&nbsp;\n    <button @click="isShowContent=false" >父组件控制-隐藏内容</button>\n  </div>\n</template>\n\n<script>\nimport HelloWorld from \'./components/HelloWorld.vue\'\nexport default {\n  name: \'App\',\n  data() {\n    return {\n      isShowContent: false\n    }\n  },\n  components: {\n    HelloWorld\n  }\n}\n<\/script>\n')])])]),e("p",[t._v("子组件")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<template>\n  <div class="hello_container">\n    <div class="content" v-show="isShow" >\n      我是子组件的内容文案！！！！！！！！！\n    </div>\n    <button @click="$emit(\'update:isShow\',true)" >子组件内控制-显示内容</button>\n    &nbsp;&nbsp;&nbsp;&nbsp;\n    <button @click="$emit(\'update:isShow\',false)" >子组件内控制-隐藏内容</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  props: [\'isShow\']\n}\n<\/script>\n')])])]),e("p",[e("em",[e("strong",[t._v("相当于用固定写法:XXX.sync向子组件传prop，而在子组件中也用固定的写法$emit('update:XXX',val)来修改父组件的data")])])]),t._v(" "),e("h3",{attrs:{id:"_2、is属性让代码更优雅"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2、is属性让代码更优雅"}},[t._v("#")]),t._v(" 2、is属性让代码更优雅")]),t._v(" "),e("p",[t._v("在业务上经常要用状态去控制不同组件的显示/隐藏，以下写法就比较low")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("<template>\n  <div id=\"app\">\n    <a-components v-if=\"type == 'a'\" ></a-components>\n    <b-components v-else-if=\"type == 'b'\" ></b-components>\n    <c-components v-else-if=\"type == 'c'\" ></c-components>\n  </div>\n</template>\n<script>\nimport aComponents from './components/a.vue'\nimport bComponents from './components/b.vue'\nimport cComponents from './components/c.vue'\nexport default {\n  data() {\n    return {\n      type: 'b'\n    }\n  },\n  components: {\n    aComponents, bComponents, cComponents\n  }\n}\n<\/script>\n")])])]),e("p",[t._v("可以换成is和component的写法，就会更清晰一点，不会让template代码区域很乱，也不需要在components属性中注册过多的组件，代码如下")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("<template>\n  <div id=\"app\">\n    <component :is=\"componentObj[type]\"></component>\n  </div>\n</template>\n\n<script>\nimport aComponents from './components/a.vue'\nimport bComponents from './components/b.vue'\nimport cComponents from './components/c.vue'\nexport default {\n  data() {\n    return {\n      type: 'a',\n      componentObj: {a: aComponents, b: bComponents, c: cComponents}\n    }\n  }\n}\n<\/script>\n")])])]),e("h3",{attrs:{id:"_3、hook"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3、hook"}},[t._v("#")]),t._v(" 3、hook")]),t._v(" "),e("p",[t._v("在vue中可以通过$on和$once去监听生命周期的钩子函数，即hook，可以让定时器的创建销毁代码在同一个生命周期函数内，如下代码")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("export default {\n  data(){\n    return {\n      timer: null\n    }\n  },\n  mounted(){\n    this.timer = setInterval(() => {\n      console.log('----setInterval-----');\n    }, 2000)\n    this.$once('hook:beforeDestroy', () => {\n      if(this.timer){\n        clearInterval(this.timer)\n      }\n      console.log('-----hook:beforeDestroy------');\n    })\n  },\n  beforeDestroy(){\n    console.log('------beforeDestroy-------');\n  }\n}\n")])])]),e("p",[t._v("在mounted方法中对timer进行了创建，同时监听beforeDestroy的hook钩子，以完成timer的销毁，在复杂的页面逻辑中还是很实用的，避免创建和销毁的代码相距很多行。以上代码的打印顺序为先beforeDestroy后hook:beforeDestroy，证明监听生命周期函数是在该函数执行完毕后再执行。")]),t._v(" "),e("p",[t._v("hook还可以用于父组件监听子组件的生命周期函数，看以下示例"),e("br"),t._v("\n父组件")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("<template>\n  <div class=\"home\">\n    <h1>This is an Home page</h1>\n    <p>监听子组件的update</p>\n    <count @hook:updated=\"childUpdateListener\" ></count>\n  </div>\n</template>\n\n<script>\nimport count from '@/components/count' \nexport default {\n  components: { count },\n  methods: {\n    childUpdateListener(){\n      console.log('-----child update-------');\n    }\n  }\n}\n<\/script>\n")])])]),e("p",[t._v("子组件")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<template>\n  <div class="hello">\n    <span>{{ count }}</span>\n    <button @click="count++" >加法</button>\n  </div>\n</template>\n<script>\nexport default {\n  data() {\n    return {\n      count: 1\n    }\n  }\n}\n<\/script>\n')])])]),e("p",[t._v("在父组件中通过@hook:updated进行子组件update函数的监听，当子组件每次count做加法触发update时，父组件都会监听到并执行childUpdateListener方法")]),t._v(" "),e("h3",{attrs:{id:"_4、使用-attrs和-listeners"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4、使用-attrs和-listeners"}},[t._v("#")]),t._v(" 4、使用$attrs和$listeners")]),t._v(" "),e("ul",[e("li",[t._v("$attrs为由父组件传入，但没有被props识别的集合对象")]),t._v(" "),e("li",[t._v("$listeners为父组件向子组件传递的监听事件集合对象\n它们的用途一方面可用于封装复杂的组件，另一方面配合v-on和v-bind可以用来父级向孙级组件传参，具体示例代码如下："),e("br"),t._v("\n父组件")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<template>\n  <div class="home">\n    <p>$attrs和$listeners</p>\n    <child p1="this is p1" p2="this is p2" p3="this is p3" \n      @tap1="test1" @tap2="test2" @tap3="test3" >\n    </child>\n  </div>\n</template>\n<script>\nimport child from \'../components/child\'\nexport default {\n  components: { child },\n  methods: {\n    // 事件1\n    test1(val){\n      console.log(`-------test1 tap in ${val}--------`);\n    },\n    // 事件2\n    test2(val){\n      console.log(`-------test2 tap in ${val}--------`);\n    },\n    // 事件3\n    test3(val){\n      console.log(`-------test3 tap in ${val}--------`);\n    }\n  }\n}\n<\/script>\n')])])]),e("p",[t._v("在父组件中向child分别传递了p1、p2、p3这三个属性，以及tap1、tap2、tap3这三个事件，然后子组件代码如下")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("<template>\n  <div class=\"child\">\n      <p>I am child</p>\n      <p>p1: {{ p1 }}}</p>\n      <button @click=\"$emit('tap1', 'child')\" >test1</button>\n      <grandson v-bind=\"$attrs\" v-on=\"$listeners\"></grandson>\n  </div>\n</template>\n<script>\nimport grandson from './grandson'\nexport default {\n  components: { grandson },\n  props: ['p1'],\n}\n<\/script>\n")])])]),e("p",[t._v("子组件中通过props属性获取了p1,这时child组件的$attrs中只有p2和p3了，且把$attrs传递给了孙子辈的组件grandson，至于$listeners无论是在子组件还是在孙子辈的组件中值都是相同的均为tap1、tap2、tap3这三个事件对象，子组件中可以通过$emit调用事件tap1。最后是孙子辈组件")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("<template>\n  <div class=\"grandson\">\n      <p>I am grandson</p>\n      <p>p2: {{ p2 }}}</p>\n      <button @click=\"$emit('tap2', 'grandson')\" >test2</button>\n      <button @click=\"$emit('tap3', 'grandson')\" >test3</button>\n  </div>\n</template>\n<script>\nexport default {\n  props: ['p2'],\n}\n<\/script>\n")])])]),e("p",[t._v("孙子辈组件通过props属性获取了p2，此时其的$attrs属性就只有p3了，同时可以使用$emit触发爷爷那辈的事件")])])}),[],!1,null,null,null);n.default=o.exports}}]);