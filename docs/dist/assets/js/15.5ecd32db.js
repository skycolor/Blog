(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{660:function(n,e,s){"use strict";s.r(e);var t=s(7),o=Object(t.a)({},(function(){var n=this,e=n.$createElement,s=n._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[s("p",[n._v("JS是单线程运行，其中任务分为宏任务（macrotask）和微任务（microtask）")]),n._v(" "),s("ul",[s("li",[n._v("macro-task(宏任务)：包括整体代码script，setTimeout，setInterval")]),n._v(" "),s("li",[n._v("micro-task(微任务)：Promise，process.nextTick"),s("br"),n._v("\n不同类型的任务会进入对应的Event Queue，比如setTimeout和setInterval会进入对应的Event Queue"),s("br"),n._v("\n整体的执行顺序为：宏任务=>微任务=>宏任务=>微任务，如此交替循环"),s("br"),n._v("\n比如下面代码")])]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("\x3c!-- 主线程直接执行 --\x3e\nasync function async1() {\n    console.log('async1 start');\n    await async2();\n    \x3c!-- 微事件 --\x3e\n    console.log('async1 end');\n}\nasync function async2() {\n    console.log('async2');\n}\n\x3c!-- 主线程直接执行 --\x3e\nconsole.log('script start');\n\x3c!-- 丢到宏事件队列中 --\x3e\nsetTimeout(function() {\n    console.log('setTimeout');\n}, 0)\n\x3c!-- 主线程直接执行 --\x3e\nasync1();\n\x3c!-- 主线程直接执行 --\x3e\nnew Promise(function(resolve) {\n    console.log('promise1');\n    resolve();\n}).then(function() {\n    \x3c!-- 微事件 --\x3e\n    console.log('promise2');\n});\n\x3c!-- 主线程直接执行 --\x3e\nconsole.log('script end');\n")])])]),s("ol",[s("li",[n._v("线程从上而下，依次定义函数~然后打印script start和执行setTimeout，setTimeout中的函数放到宏任务的Event Queue中")]),n._v(" "),s("li",[n._v("接着执行async1方法，打印async1 start和async2，然后将async1方法中的await后的函数放入微任务中")]),n._v(" "),s("li",[n._v("接着执行Promise方法，打印promise1，将then方法放入微任务，然后打印最后的script end")]),n._v(" "),s("li",[n._v("第一轮宏任务执行完毕，开始执行微任务，按2 3中描述的就是依次打印async1 end和promise2")]),n._v(" "),s("li",[n._v("微任务执行完毕，开始执行第二轮宏任务，即setTimeout中的setTimeout，此时已经无微任务了，代码执行完毕"),s("br"),n._v("\n最后依次打印script start、async1 start、async2、promise1、script end、async1 end、promise2、setTimeout")])])])}),[],!1,null,null,null);e.default=o.exports}}]);